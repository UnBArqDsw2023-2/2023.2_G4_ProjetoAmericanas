# 4.2. Módulo Reutilização de Software

## Introdução

<div align="jutify">
&emsp;&emsp;Na maioria dos projetos de software, há algum reúso de software. Isso acontece muitas vezes informalmente,
quando as pessoas envolvidas no projeto sabem de projetos ou códigos semelhantes ao que é exigido. Elas os
buscam, fazem as modificações necessárias e incorporam-nos a seus sistemas. Apesar de o reúso ter sido proposto como uma
estratégia de desenvolvimento há mais de 40 anos (McILROY, 1968), só em 2000 o ‘desenvolvimento com reúso’ se tornou
a norma para novos sistemas de negócios. A mudança para o desenvolvimento baseado em reúso foi uma resposta às
exigências de menores custos de produção e manutenção de software, entregas mais rápidas de sistemas e softwares de
maior qualidade. Cada vez mais empresas consideram o software como um ativo valioso. O reúso tem sido promovido
para aumentar o retorno sobre os investimentos em software.(Sommerville, Ian. 2011) Exemplos de unidade de software reutilizaveis:

1. **Reúso de sistema de aplicação.** A totalidade de um sistema de aplicação pode ser reusada sem alterações em outros
sistemas ou pela configuração da aplicação para diferentes clientes. Como alternativa, podem ser desenvolvidas
297Capítulo 16 Reúso de software
famílias de aplicações com uma arquitetura comum, mas adaptadas para clientes específicos. Ainda neste capítulo,
eu trato do reúso de sistemas de aplicação.
2. **Reúso de componentes.** Os componentes de uma aplicação, variando em tamanho desde subsistemas até objetos
únicos, podem ser reusados. Por exemplo, um sistema de identificação de padrões desenvolvido como parte de
um sistema de processamento de textos pode ser reusado em um sistema de gerenciamento de banco de dados.
Trato de reúso de componentes nos capítulos 17 e 19.
3. **Reúso de objetos e funções.** Componentes de software que implementam uma única função, como uma função
matemática ou uma classe de objeto, podem ser reusados. Essa forma de reúso, baseada em bibliotecas-padrão,
tem sido comum nos últimos 40 anos. Muitas bibliotecas de funções e classes estão disponíveis gratuitamente.
Você reusa as classes e funções nessas bibliotecas, ligando-as com o código da aplicação recém-desenvolvido. Essa
é uma abordagem particularmente eficaz em áreas como algoritmos e gráficos matemáticos, em que o conheci-
mento especializado é necessário para o desenvolvimento de funções e objetos eficientes

</div>

## Objetivo

<div align="jutify">
&emsp;&emsp; O objetivo do artefato em questão é propor um design arquitetural focado em reuso de código e componentes para a aplicação das Lojas Americanas, levando em consideração conceitos e tecnologias que podem ser utilizadas para tal. 
</div>

## Metodologia

<div align="jutify">
&emsp;&emsp; As propostas de projeto, design e tecnologias sustentadas nesse artefato foram discutidas e pensadas em grupo e visando entender melhor e aplicar os aos conceitos apresentados nas aulas de arquitetura e reuso de software.
</div>

## Desenvolvimento

### Reuso de Conceito

Os componentes e os sistemas de software são entidades potencialmente reusáveis, mas, algumas vezes, sua natureza
específica significa que é caro modificá-los para uma nova situação. Uma forma complementar de reúso é o ‘reúso
de conceito’, em que, em vez de reusar um componente de software, você reusa uma ideia, uma forma, um trabalho ou
um algoritmo. Pode, portanto, ser configurado e adaptado para uma série de situações. O conceito de
reúso pode ser incorporado em abordagens como **padrões de projeto**, que é a forma que reuso que foi desendolvida nessa seção.(Sommerville, Ian. 2011)

#### Pedido - Observer/Adapter

#### Pagamento - Strategy

<div aling="justify">
&emsp;&emsp;Durante o curso, exploramos conceitos de padrões de projeto. Após essa etapa, ao analisar nosso projeto, identificamos a oportunidade de implementar o padrão de projeto Strategy. Essa decisão visa aprimorar o projeto, especialmente no que diz respeito às funcionalidades de pagamento dos produtos das Lojas Americanas.
  
&emsp;&emsp;Baseado no <a href="https://unbarqdsw2023-2.github.io/2023.2_G4_ProjetoAmericanas/#/Modelagem/Estaticos/classes">diagrama de classes</a>, podemos identificar os seguinte ponto crítico(Hot-Spots): a classe de Pagamento. Poderíamos melhorar sua estrutura ao evitar a implementação de todos os métodos de pagamento diretamente nela. Em vez disso, seria mais eficaz criar classes específicas para lidar com as diferentes estratégias de pagamento necessárias. Com essa abordagem em mente, desenvolvemos a seguinte modelagem:
</div>

<div align="center">

  <img title="Diagrama de Classes do Pagemento implementado com Strategy" alt="Diagrama de Classes com strategy" src="https://raw.githubusercontent.com/UnBArqDsw2023-2/2023.2_G4_ProjetoAmericanas/main/docs/images/t3-Arquitetura/Strategy.png" width="100%">
  <h4> Figura 1: Diagrama de Classes do Pagemento implementado com Strategy </h4>
  <p> Fonte: Autoria própria </p>
  <p> Autor: Bruno Ribeiro, Igor Penha e Lucas Gobbi, 2023 </p>
</div>

<div aling="justify">
&emsp;&emsp; Utilizando a linguagem Java, que segue o paradigma de Orientação a Objetos, e considerando a importância dos componentes e da Reutilização de Software, optamos por importar as classes para o arquivo [StrategyPayment.java](). As classes importadas são reutilizadas ao longo do código para exemplificar as estratégias de pagamento, como Pix, Cartão e Boleto. Vale destacar que esses métodos de pagamento entram em ação durante a compra de um produto. Dessa forma, o módulo Produto também é reutilizado.
</div>

```java
package strategy;

public interface Pagamento {
	public void pagar(double valor);
}
```

```java
package strategy;
import java.text.Locale

public class PagamentoComCartao implements Pagamento {
	private String nomeCartao;
	private String numeroCartao;
	private int cvv;
	private String validade;
	public PagamentoComCartao(String nomeCartao, String numeroCartao, int cvv, String validade) {
		this.nomeCartao = nomeCartao;
		this.numeroCartao = numeroCartao;
		this.cvv = cvv;
		this.validade = validade;
	}
	@Overrride
	public void pagar(double valor) {
		double valorFormatado = Double.valueOf(String.format(Locael.US, "$.2f", valor));
		System.out.println (valorFormatado + " pago com cartão de credito/debito");
		System.out.println ("Os detalhes do cartão são:");
		System.out.println ("Nome do dono do cartão: " + this.nomeCartao);
		System.out.printIn ("Numero do cartão: " + this.numeroCartao);
		System.out.println ("cvv do cartão: " + this.cvv);
		System.out.printIn ("Data de validade do cartão: " + this.validade);
	}
}
```

```java
package strategy;

public class PagamentoComBoleto implements Pagamento {
	private String codigoBoleto;
	public PagamentoComBoleto (String codigoBoleto) {
		this.codigoBoleto = codigoBoleto;
	}
	@Override
	public void pagar (double valor) {
		double valorFormatado = Double.value0f(String.format(Locale.US, ".2f", valor)):
		System. out.printIn (valorFormatado + " pago com boleto bancário");
		System. out.println ("Os dados do boleto são:");
		System. out.println ("Código do boleto bancário: " + this.codigoBoleto);
	}
}
```
```java
package strategy;
import java.text.Locale

public class PagamentoComPix implements Pagamento {
	private String chavePix;
	public PagamentoComPix(String chavePix) {
		this.chavePix = chavePix;
	}
	@Overrride
	public void pagar(double valor) {
		double valorFormatado = Double.valueOf(String.format(Locael.US, "$.2f", valor));
		System.out.println (valorFormatado + " pago com pix");
		System.out.println ("Os detalhes do pix são:");
		System.out.println ("Chave pix: " + this.chavePix);
	}
}
```


#### Usuario - <padrão utilizado>

#### Cesta/Produto - <padrão utilizado>

### Reuso Externo


<div align="jutify">
&emsp;&emsp;Fazer o desenvolvimento do artefato. Adicionar, caso necessário, mais tópicos personalizados e relacionados ao seu artefato. 
</div>

## Resultado e conclusões

<div align="jutify">
&emsp;&emsp;Discorrer e analisar as conclusões do artefato. A depender, trocar o nome desse tópico para apenas "Conclusão".
</div>

## Referências

> * Sommerville, Ian. Engenharia de Software / Ian Sommerville ; tradução Ivan Bosnic e Kalinka G.
>de O. Gonçalves ; revisão técnica Kechi Hirama. — 9. ed. — São Paulo : Pearson
>Prentice Hall, 2011.


##  Histórico de Versão

|  Versão  |   Data da alteração  |   Alteração  |  Responsável  |  Revisor  | Data de revisão |
| :--------: | :--------------------: | :-----------: | :--------------: | :--------: | :-----------------: |
|     `1.0`     |    30/11/2023   |  Criando documento  |  [Bernardo Pissutti](https://github.com/berssutti)   |   |  |
|     `1.1`     |    30/11/2023   |  Add o reuso utilizando o padrão de projeto Strategy  |  [Bruno Ribeiro](https://github.com/BrunoRiibeiro) e [Igor Penha](https://github.com/igorpenhaa) | [Bruno Martins](https://github.com/gitbmvb) | 30/11/2023 
|     `1.2`     |    30/11/2023   |  Add o codigos Strategy  |  [Bruno Ribeiro](https://github.com/BrunoRiibeiro) e [Igor Penha](https://github.com/igorpenhaa) | [Bruno Martins](https://github.com/gitbmvb) | 30/11/2023 |
